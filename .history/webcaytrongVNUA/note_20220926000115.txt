Hàm .destroy() chỉ thực hiện được khi đứng trước nó là 1 object của Sequelize.

Đối với các function(hàm) dùng để xử lý(handle) sự kiện(evenet) onChange, onClick, on... các kiểu, thì ta nên dùng arrow function khi 
thực hiện gán lệnh cho onClick, onChange...

-Props là các biến, data được truyền từ component cha và có thể truy cập được ở cả các component con.

-State được khởi tạo và chỉnh sửa và chỉ có thể truy cập bởi chính bản thân component chứa nó.
 -Điểm khác nhau lớn nhất giữa props và state đó là props không thể thay đổi,
-  còn state có thể thay đổi do đó hiệu năng của props tốt hơn state.


... (there dots): là copy và paste trong ReactJs

với hàm map trong JS, ta không thể dùng lệnh break;

alert không giúp sinh ra 1 object;

để truyền fire events từ con sang cha, ta dùng props
 để truyền fire events từ cha sang con, ta dùng ref
 nếu  phải thao tác vs database, ta có thể dùng emitter(áp dụng cho cả bên cha lẫn con), cơ chế hoạt động của emitter khá giống chat real-time

 với emitter thì bên nào muốn nhận fire event, thì ta dùng emitter.on(), còn bên nào gửi fire event, thì dùng emitter.emit(),

 React.Fragments giúp ta viết code ngắn hơn mà vẫn render đúng thứ thự của html/css. Link: https://freetuts.net/fragments-trong-reactjs-2433.html

 Redux chạy xong xong với React, giống như local storage, lưu trữ mọi biến và giúp quản lý state cho React, nhờ đó, nhiều component chỉ cần gọi
  state đã lưu từ redux mà không cần thiết phải gọi lại API.

  đổi ngôn ngữ thì sang điều chỉnh lại file appReducer.js

  muốn xác định đang có logic bug ở file nào, hãy vào file web.js đầu tiên

  với prj này, sau khi thay đổi thông tin của người dùng, ta cần logout ra bên ngoài rồi đăng nhập lại để redux persit load lại

  muốn tìm path hoặc đặt thêm path cần thao tác, đến file System.js và đặt path khác

  axios là 1 thư viện lấy và gửi thông tin từ phía client về server

  muốn fire 1 actions của redux(hay là gọi 1 action của redux, ta phải bọc dispatch vào trong hàm đó).

  hàm componentDidUpdate( prevProps,prevState, snapshot) luôn luôn chạy khi app chạy thành công, muốn hàm đó chạy thì ta phải
  đặt điều kiện so sánh trước và sau của các props rồi thực hiện hành động ta muốn.
   VD:
   
   componentDidUpdate( prevProps,prevState, snapshot){
    if(prevProps.genderRedux !== this.props.genderRedux
      
          ){
        this.setState({
            genderArr: this.props.genderRedux,
          
        })
    }
    if(prevProps.positionRedux !== this.props.positionRedux){
      this.setState({
        positionArr: this.props.positionRedux,
      })
    }
    if(prevProps.roleIdRedux !== this.props.roleIdRedux){
      this.setState({
        roleIdArr: this.props.roleIdRedux,
      })
    }
}


trong 1 object {} thì không thể có dấu ()

Luồng chạy của JS:
Đầu tiên sẽ chạy vào constructor, sau đó chạy vào hàm render(), sau đó chạy vào hàm
componentDidMount, sau đó sẽ chạy sang file chứa các action đã fire, sau đó chạy đến hàm chứa
dispatch(type: actionTypes....)  ở file đó và chạy các câu lệnh phía dưới,
sau đó nhảy vào file Redux,
 (riêng câu lệnh dispatch nếu không có gì ở phía dưới thì nhảy vào switch/case file Reducer),

 sau đó chạy vào componentDidUpdate trong file redux


 Muốn thao tác với redux, việc đầu tiên là định nghĩa tên của action đó trong actionTypes, sau đó export
 ở các file khác như appActions/ adminActions/ userActions.

 Tiếp tới, viết các hàm để dispatch() các action vừa viết đó(bắt buộc).

 Khi muốn thực thi 1 hàm ở redux trên phía react, ta phải fire tên của funtion đó ra, 
 tên function đó thường được người dùng tự định nghĩa ở hàm mapStateToProps() với các
 câu lệnh nhỏ, với bên trái là tên người dùng tự định nghĩa, bên phải là function đã được định nghĩa bên redux.


 mapStateToProps() là lấy state của redux(Thường nằm trong file Reducer) rồi bơm vào props của reactjs
 mapDispatchToProps() là lấy câu lệnh của redux(Thường nằm trong file Action) rồi bơm vào props của reactjs


khi gán data, bên nào có this.state thì bên đó không phải là tên cột mặc định của database

Việc dùng promise để chắc chắn code luôn ra được kết quả(trong cả trường hợp đúng lẫn sai)

trong import, .. tức là nhảy ra thư mục ở bên ngoài.

actions mà ta thấy trong file Reducer chính là những câu lệnh có trong dispatch({}) của file actions
vd: 

  dispatch({
        type: actionTypes.FETCH_TOP_DOCTORS_SUCCESS,
        dataDoctors: res.data
    })

trong hàm mapStateToProps(), phần admin/app/user... trong các câu lệnh phía dưới chính là phần
đại diện cho các file adminReducer/userReducer/appReducer...

để render động từ database khi có update, ta phải đặt constructor với các state mà ta muốn hiển thị

muốn tạo 1 route mới(kiểu như phân trang mới trong reactJS, thì nhớ đến class chứa nội dung mà ta muốn xếp, để thêm link và name ),
 sau đó chạy đến file App để nhập route, path, component mà ta muốn đặt (nhớ phải import class đó),
rồi sau đó có thể hoặc không export const path thêm ở file constant.js

muốn tạo 1 API mới, kết hợp với reactJS, xem bài 67.

Mô tả về cách viết các quan hệ trong sequelize:

A.hasOne(B), thì khóa ngoại chính là khóa chính của bảng B 
A.belongsTo(B), thì khóa ngoại chính là khóa chính của bảng A 
Muốn tạo quan hệ nhiều nhiều, ta nên tạo 1 bảng mới chứa các thông tin chung của 2 bảng rồi làm 
nên các mối quan hệ 1 nhiều. VD: https://tanducits.com/thu-thuat/tong-quan-ve-moi-quan-he-relationships-giua-cac-bang-trong-access


Khi viết một hàm mà muốn thao tác với object thông qua ID của object, ta phải truyền id đó vào
bằng câu lệnh (req.query.id)

withRouter ở trong thư viện 'react-router', mục đích để chuyển trang, ví dụ như onclick to href 
trong html css, muốn phần trong reactjs nào có chuyển trang, thì viết vào trong class js đó

Những câu lệnh nằm trên hàm return sẽ có khả năng áp dụng toàn bộ vào hàm return phía sau, tùy ý đồ của chúng ta

khi muốn show hay hiện 1 thứ gì đó ở link mới, chỉ cần định nghĩa isShowHeader, isShowBanner... hay gì đó rồi set giá trị true false cho từng
nơi

để lấy thông tin doctor(ở phần logic database), lần lượt ta xem qua các class sau: web.js, doctorController.js, doctorService.js(NodeJs) và DetailDoctor.js,
 userService.js(React)

 Còn ở phần tạo route, sẽ nằm trong file constant.js, App.js.
  Lưu ý: Route path ở file App.js có thể thay đổi linh hoạt tùy nơi 
